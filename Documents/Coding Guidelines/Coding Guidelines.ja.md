# コーディングのガイドライン

## 準備

ソースファイルは、数が多い場合、シンプルな階層構造に収まっているべき。ソースファイルだけを一カ所にまとめるために "Source" のようなディレクトリーを作らない。そうすれば UI などのファイルと区別できるが、それらも散らかるし、それらにもソースファイルが関連づけられる。それらはプロジェクトのルートディレクトリーに置かれなければならないことがある。

## 設計

それぞれのクラスが適度に SOLID であるべき。完璧を目指すと開発が遅れるので「適度」を考える。GitHub Copilot にそれぞれのソースファイルが SOLID かどうか聞くのも有用。

静的メソッドにより値の更新される静的プロパティーを含む静的クラスを作らない。そういったものを、ほかのクラスのインスタンスを返す get だけの静的プロパティーにする。

コレクションのプロパティーを作るときにインターフェースと通常のクラスを適切に区別する。モデルクラス内では、nullable で、インターフェースを get/set で扱うプロパティーが適する。通常のクラス内では、機能性やパフォーマンスにより優れる通常のクラスを、nullable でない get/private-set のプロパティーとして含めるのが良い。ここでの「モデルクラス」とは、JSON との変換が行われたり、ほかのインスタンスとのデータのマッピングが行われたりのものを言う。

コードを過度にカスタマイズ可能にしない。たとえば改行は Environment.NewLine に、エンコーディングは Encoding.UTF8 にフォールバックしてよい。フォールバック先も指定できたり、環境により自動的に切り替わったりの設計は、実装するのも使うのもコストが大きい。

## 実装

できるだけ Lazy クラスを使い、必要になってから初期化されるプロパティーを多くする。起動が速くなるだけでなく、SOLID 性の向上にもつながる。

コレクションのプロパティーの名前は、それらの型や構造でなく内容により決められるべき。たとえば、自動的に拡大するリストのクラスを作るにおいて、そのデータ本体の List 型のプロパティーの名前は、List より Items が適する。

変数名を適度に統一する。値型や enum なら "value"、DateTime なら "utc" や "localTime"、object やインスタンスなら "object" または "obj"、文字列なら "string" または "str"、配列なら "array"、コレクションや IEnumerable なら "items" を考える。string に "value" や "text" を使うのでは、前者ではほかの引数との衝突の可能性が高く、後者では複数形に違和感が生じる。

JSON のキー名は、アンダースコアでつながれた小文字の識別子であるべき。ユーザーによる編集の可能性のあるものなら、キーの照合は大文字・小文字の区別なく行われるべき。それだとパフォーマンスが気になるところには、そもそも JSON は適さない。

インスタンスの変換や前処理のメソッドは、null が与えられたときに null またはそれに相当するものを返すべき。たとえば文字列を行分割する場合、入力が null でも空の配列や List が得られるべき。null は、「不定」や「未設定」だけを意味するものでなく、「デフォルト値にフォールバックしてほしい」を意味することもある。単純な変換や前処理においても null が積極的にエラー扱いされるのでは、プログラムの安定性が損なわれる。

IsNullOrEmpty より IsNullOrWhiteSpace を積極的に使う。たいてい最初の方で何かヒットするのでパフォーマンスの違いは微々たるもの。それでいて後者では「見える文字の含まれる、有効な文字列か」ということを確認できる。前者を使うのは、自分が実装したコード内で「null でなければ確実に値が存在する」などの条件が成立するときに限られるべき。

IEnumerable の代わりのものを返すメソッドには、配列を返すものと List を返すものの両方を用意する。容易に変換できるが、片方だけを用意するのでは、二重変換になることがある。

それぞれのメソッドを呼び出す側が、そのメソッド内で発生する全ての中間データにアクセスできるようにする。例としては、サーバーからの応答だったり、一時的に生成されたパスだったりが挙げられる。

全ての disposable なインスタンスが Dispose されるのを確認する。

## 品質管理

大きなクラスを partial にして、*Helper.cs ファイルの方にバックエンド的な処理を詰め込む。UI とロジックのコードが密結合になりがちなフレームワークを使っての開発においても、二つの partial クラスの利用により、できるだけ UI とロジックを分離する。

スレッドセーフでないクラスやメソッドには summary のコメントをつけ、使う側が必要に応じて lock できるようにする。

ライブラリーに機能を追加するにおいては、一人で使うアプリのためのものなのか、大勢が使うシステムのためのものなのかを区別する。後者の場合、千人がその機能に同時にアクセスするとか、千のインスタンスが生成されるとかの過負荷の状態を想定してみる。

ライブラリーの仕様に大きな違和感があり、そこからの派生開発に心理的抵抗を覚えるなら、破壊的変更をいとわず大きく改善する。好きな仕様でないが、変更するのも大変だという理由で開発を停滞させたことが過去に何度かあるが、自分は最終的には必ず書き直した。迷うだけ時間の無駄だ。

## チェック

TODO コメントがソースファイル内に残っていないのを確認する。

モデルクラスの各プロパティーに、必要に応じて JsonConverter が指定されているのを確認する。

出力される文字列が見えるのを確認する。null や空の文字列になりうるところに GetVisibleString を適用する。

出力されるメッセージのフォーマットが適度に整合していて、ユーザーがすぐに理解できるようになっているのを確認する。

ファイル名にアンダースコアでなくハイフンが使われているのを確認する。アンダースコアは URL の下線と重なることがある。

https://developers.google.com/search/docs/crawling-indexing/url-structure
